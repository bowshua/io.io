<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Phaser Fullscreen Game</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@v3.16.2/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }

    #game-container {
      width: 1920px;
      height: 1080px;
      margin: auto;
    }
  </style>
</head>

<body>

<div id="game-container"></div>

<script>

var config = {
  type: Phaser.Canvas,
  roundPixels: true,
  width: 1920,
  height: 1080,
  parent: 'game-container',
  physics: {
    default: 'arcade',
    arcade: {
      fixedStep: false,
      debug: true,
      debugShowBody: true,
      fps: 360
    }
  },
  scene: {
    preload: preload,
    create: create,
    update: update
  }
};

var game = new Phaser.Game(config);

// ================= GLOBAL VARIABLES =================
var player;
var tree;
var rock;
var iron;

var cursors;
var keys;
var pointer;

// CONTACT COUNTS (PER FRAME)
var treeTouchCount = 0;
var rockTouchCount = 0;
var ironTouchCount = 0;

// ===== DAY / NIGHT =====
var timeOfDay = 0;           // 0 â†’ 1
const DAY_LENGTH = 1;     // seconds for a full cycle
var dayNightOverlay;

// RESOURCES
var resourceWood = 100;
var resourceStone = 100;
var resourceIron = 100;

// FARM RATE PER OBJECT
const FARM_RATE = 0.01;

var yLimit;
var xLimit;

const BUILD_TILE_SIZE = 78;
var buildPreview;
const WORKBENCH_CLEAR_RADIUS_TILES = 15;

var workbenches;

const background_size = 468;
const background_chunk_width = 8;
const background_chunk_height = 5;
var background = [];

// ===== DAY / NIGHT =====
var timeOfDay = 0;        // 0 â†’ 1

// ===== ZOMBIES =====
var zombies;
var zombieSpawnedThisNight = false;

const ZOMBIE_SPAWN_DISTANCE_TILES = 20;


var playerXChunk = undefined;
var playerYChunk = undefined;

// ================= HOTBAR =================
const HOTBAR_SLOTS = 9;
var hotbarSlots = [];
var hotbarIcons = [];
var selectedHotbarSlot = 0;

// ================= PRELOAD =================
function preload() {
  this.load.image('floor', 'assets/therealtile.png');
  this.load.image('player', 'assets/playerwithaxe.png');
  this.load.image('tree', 'assets/tree.png');
  this.load.image('rock', 'assets/rock.png');
  this.load.image('iron', 'assets/iron.png');
  this.load.image('axe', 'assets/axe.png');
  this.load.image('playerworkbench', 'assets/playerworkbench.png');
  this.load.image('workbench', 'assets/workbench.png');
  this.load.image('zombie', 'assets/zombie.png');
}

// ================= HELPERS =================
function closestChunkBoundary(position) {
  return Math.floor(position / background_size) * background_size;
}

function backgroundDifferenceBehind(count) {
  return background_size * Math.ceil(count / -2);
}

function backgroundDifferenceInFront(count) {
  return background_size * Math.floor(count / 2);
}

function snapToBuildTile(value) {
  return Math.floor(value / BUILD_TILE_SIZE) * BUILD_TILE_SIZE;
}

function isNight() {
  return timeOfDay > 0.45 && timeOfDay < 0.55;
}

function getZombieSpawnPosition() {

  const bench = workbenches.getChildren()[0];
  if (!bench) return null;

  const distance = ZOMBIE_SPAWN_DISTANCE_TILES * BUILD_TILE_SIZE;

  // Random angle around workbench
  const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);

  let x = bench.x + Math.cos(angle) * distance;
  let y = bench.y + Math.sin(angle) * distance;

  // Clamp inside world bounds
  x = Phaser.Math.Clamp(x, 0, xLimit);
  y = Phaser.Math.Clamp(y, 0, yLimit);

  return { x, y };
}

function updateWorkbenchClaimOverlay() {

  if (workbenches.countActive(true) === 0) {
    workbenchClaimOverlay.setVisible(false);
    return;
  }

  const bench = workbenches.getChildren()[0];

  const tiles = WORKBENCH_CLEAR_RADIUS_TILES;
  const half = Math.floor(tiles / 2);
  const size = tiles * BUILD_TILE_SIZE;

  // Snap bench to tile origin
  const tileX = snapToBuildTile(bench.x - BUILD_TILE_SIZE / 2);
  const tileY = snapToBuildTile(bench.y - BUILD_TILE_SIZE / 2);

  // Top-left of 11x11 area
  const x = tileX - half * BUILD_TILE_SIZE;
  const y = tileY - half * BUILD_TILE_SIZE;

  workbenchClaimOverlay.clear();

  // âœ… Black perimeter outline only
  workbenchClaimOverlay.lineStyle(3, 0x000000, 0.9);
  workbenchClaimOverlay.strokeRect(x, y, size, size);

  workbenchClaimOverlay.setVisible(true);
}


function handleBuildPreview() {

  // Only when workbench selected
  if (selectedHotbarSlot !== 1) {
    buildPreview.setVisible(false);
    return;
  }

  const tileX = snapToBuildTile(pointer.worldX);
  const tileY = snapToBuildTile(pointer.worldY);

  // World bounds check
  const inBounds = isBuildTileInBounds(tileX, tileY);


  const canAfford =
    resourceWood >= 30 &&
    resourceStone >= 30 &&
    resourceIron >= 10;


  const tileClear = isBuildTileClear(tileX, tileY);

  const valid = canAfford && tileClear && inBounds;
  
  buildPreview.clear();
  buildPreview.lineStyle(2, valid ? 0x00ff00 : 0xff0000, 0.9);
  buildPreview.strokeRect(tileX, tileY, BUILD_TILE_SIZE, BUILD_TILE_SIZE);
  buildPreview.setVisible(true);

}

function isBuildTileClear(x, y) {
  const tileRect = new Phaser.Geom.Rectangle(
    x,
    y,
    BUILD_TILE_SIZE,
    BUILD_TILE_SIZE
  );

  let blocked = false;

  tree.getChildren().forEach(obj => {
    if (Phaser.Geom.Intersects.RectangleToRectangle(tileRect, obj.getBounds())) {
      blocked = true;
    }
  });

  rock.getChildren().forEach(obj => {
    if (Phaser.Geom.Intersects.RectangleToRectangle(tileRect, obj.getBounds())) {
      blocked = true;
    }
  });

  iron.getChildren().forEach(obj => {
    if (Phaser.Geom.Intersects.RectangleToRectangle(tileRect, obj.getBounds())) {
      blocked = true;
    }
  });

  workbenches.getChildren().forEach(obj => {
    if (Phaser.Geom.Intersects.RectangleToRectangle(tileRect, obj.getBounds())) {
      blocked = true;
    }
  });

  return !blocked;
}

function isBuildTileInBounds(x, y) {
  return (
    x >= 0 &&
    y >= 0 &&
    x + BUILD_TILE_SIZE <= xLimit &&
    y + BUILD_TILE_SIZE <= yLimit
  );
}

function tryPlaceWorkbench() {

  if (selectedHotbarSlot !== 1) return;
  if (!pointer.justDown) return;

  // âŒ Already have a workbench
  if (workbenches.countActive(true) > 0) return;

  const tileX = snapToBuildTile(pointer.worldX);
  const tileY = snapToBuildTile(pointer.worldY);

  if (!isBuildTileInBounds(tileX, tileY)) return;

  if (
    resourceWood < 30 ||
    resourceStone < 30 ||
    resourceIron < 10
  ) return;

  if (!isBuildTileClear(tileX, tileY)) return;

  // Deduct resources
  resourceWood -= 30;
  resourceStone -= 30;
  resourceIron -= 10;

  // Place workbench
  const bench = workbenches.create(
    tileX + BUILD_TILE_SIZE / 2,
    tileY + BUILD_TILE_SIZE / 2,
    'workbench'
  );

  bench.setScale(1);

  bench.body.setSize(48, 48, true);
  bench.refreshBody();

  // ðŸ”¥ CLEAR CLAIM AREA
  clearResourcesAroundWorkbench(tileX, tileY);
}

function clearResourcesAroundWorkbench(tileX, tileY) {

  const half = Math.floor(WORKBENCH_CLEAR_RADIUS_TILES / 2);
  const size = WORKBENCH_CLEAR_RADIUS_TILES * BUILD_TILE_SIZE;

  // Top-left of the clear area
  const clearX = tileX - half * BUILD_TILE_SIZE;
  const clearY = tileY - half * BUILD_TILE_SIZE;

  const clearRect = new Phaser.Geom.Rectangle(
    clearX,
    clearY,
    size,
    size
  );

  // Helper to destroy intersecting objects
  function clearGroup(group) {
    group.getChildren().forEach(obj => {
      if (Phaser.Geom.Intersects.RectangleToRectangle(
        clearRect,
        obj.getBounds()
      )) {
        obj.destroy();
      }
    });
  }

  clearGroup(tree);
  clearGroup(rock);
  clearGroup(iron);

  clearGroup(tree);
  clearGroup(rock);
  clearGroup(iron);
}

// ================= CREATE =================
function create() {
  this.physics.world.setBounds(0, 0, xLimit, yLimit);
  var playerp_ox = Phaser.Math.Between(0, 4680);
  var playerp_oy = Phaser.Math.Between(0, 4680);

  playerXChunk = closestChunkBoundary(playerp_ox);
  playerYChunk = closestChunkBoundary(playerp_oy);

  xLimit = 4680;
  yLimit = 4680;

  // ===== BACKGROUND =====
  for (var i = backgroundDifferenceBehind(background_chunk_width); i <= backgroundDifferenceInFront(background_chunk_width); i += background_size) {
    var xArray = [];
    for (var j = backgroundDifferenceBehind(background_chunk_height); j <= backgroundDifferenceInFront(background_chunk_height); j += background_size) {
      var image = this.add.image(
        closestChunkBoundary(playerp_ox + i),
        closestChunkBoundary(playerp_oy + j),
        'floor'
      );
      image.setScale(3);
      image.depth = -5;
      xArray.push(image);
    }
    background.push(xArray);
  }

  // ===== PLAYER =====
  player = this.physics.add.sprite(playerp_ox, playerp_oy, 'player');
  player.setScale(3);
  player.setCircle(16, 15, 15);



  pointer = this.input.activePointer;
  cursors = this.input.keyboard.createCursorKeys();
  keys = this.input.keyboard.addKeys({
    up: 'W', left: 'A', down: 'S', right: 'D',
    one: 'ONE', two: 'TWO', three: 'THREE', four: 'FOUR',
    five: 'FIVE', six: 'SIX', seven: 'SEVEN', eight: 'EIGHT', nine: 'NINE'
  });

  this.cameras.main.setBounds(-955, -520, xLimit + 1920, yLimit + 1080);

  // ===== WORLD EDGE DARKENING OVERLAY =====

  // ===== WORLD EDGE DARKENING OVERLAY =====

// Dark overlay (covers entire screen)
this.worldEdgeOverlay = this.add.graphics();
this.worldEdgeOverlay.fillStyle(0x000000, 0.35);
this.worldEdgeOverlay.fillRect(-4000, -4000, 8000, 8000);
this.worldEdgeOverlay.setScrollFactor(0);

// Mask shape (playable area hole)
this.worldEdgeMask = this.make.graphics({ x: 0, y: 0, add: false });
this.worldEdgeMask.fillStyle(0xffffff);
this.worldEdgeMask.fillRect(0, 0, xLimit, yLimit);

// Apply inverted mask
const mask = new Phaser.Display.Masks.GeometryMask(this, this.worldEdgeMask);
mask.invertAlpha = true;
this.worldEdgeOverlay.setMask(mask);

// Depth
this.worldEdgeOverlay.setDepth(-4);

// ===== DAY / NIGHT OVERLAY =====
dayNightOverlay = this.add.graphics();
dayNightOverlay.setScrollFactor(0);
dayNightOverlay.setDepth(999); // above world, below UI  

  // ===== RESOURCE GROUPS =====
  tree = this.physics.add.staticGroup();
  rock = this.physics.add.staticGroup();
  iron = this.physics.add.staticGroup();

  for (let i = 0; i < 20; i++) {
    let tx = Phaser.Math.Between(0, 4680);
    let ty = Phaser.Math.Between(0, 4680);

    tree.create(tx, ty, 'tree').setScale(3);
    rock.create(tx + Phaser.Math.Between(60, 300), ty + Phaser.Math.Between(60, 300), 'rock').setScale(3);
    iron.create(tx + Phaser.Math.Between(120, 450), ty + Phaser.Math.Between(120, 450), 'iron').setScale(3);
  }

  this.physics.add.collider(player, tree, () => treeTouchCount++);
  this.physics.add.collider(player, rock, () => rockTouchCount++);
  this.physics.add.collider(player, iron, () => ironTouchCount++);


  // ===== WORKBENCH GROUP =====
  workbenches = this.physics.add.staticGroup();
  this.physics.add.collider(player, workbenches);

  // ===== WORKBENCH CLAIM OVERLAY =====
  workbenchClaimOverlay = this.add.graphics();
  workbenchClaimOverlay.setDepth(2); // above ground, below player
  workbenchClaimOverlay.setVisible(false);

  // ===== ZOMBIE GROUP =====
  zombies = this.physics.add.group();

  // Optional: zombie â†” player collision
  this.physics.add.collider(player, zombies);

  // ===== HUD =====
  this.treeCount = this.add.text(20, 20, '', { font: '18px Arial', fill: '#ffffff' }).setScrollFactor(0);
  this.rockCount = this.add.text(20, 45, '', { font: '18px Arial', fill: '#ffffff' }).setScrollFactor(0);
  this.ironCount = this.add.text(20, 70, '', { font: '18px Arial', fill: '#ffffff' }).setScrollFactor(0);

  // ===== DIAGNOSTIC TEXT (RESTORED) =====
  this.angleText = this.add.text(player.x, player.y, '');
  this.posx = this.add.text(player.x, player.y, '');
  this.posy = this.add.text(player.x, player.y, '');
  this.curx = this.add.text(player.x, player.y, '');
  this.cury = this.add.text(player.x, player.y, '');

  this.input.on('pointermove', function (pointer) {
    var angle = Phaser.Math.RAD_TO_DEG *
      Phaser.Math.Angle.Between(player.x, player.y, pointer.worldX, pointer.worldY);

    player.setAngle(angle);
    this.angleText.text = 'angle: ' + angle.toFixed(2);
    this.curx.text = 'pcurx ' + pointer.worldX.toFixed(1);
    this.cury.text = 'pcury ' + pointer.worldY.toFixed(1);
  }, this);

  // ===== FULLSCREEN BUTTON =====
  this.fullscreenButton = this.add.text(1900, 20, '[ FULLSCREEN ]', {
    font: '16px Arial',
    fill: '#ffffff',
    backgroundColor: '#000000',
    padding: { x: 6, y: 4 }
  })
    .setOrigin(1, 0)
    .setScrollFactor(0)
    .setInteractive({ useHandCursor: true })
    .setDepth(1000);

  this.fullscreenButton.on('pointerup', () => {
    if (!this.scale.isFullscreen) this.scale.startFullscreen();
    else this.scale.stopFullscreen();
  });

  this.scale.on('enterfullscreen', () => this.fullscreenButton.setText('[ EXIT FULLSCREEN ]'));
  this.scale.on('leavefullscreen', () => this.fullscreenButton.setText('[ FULLSCREEN ]'));

  // ===== HOTBAR UI =====
  createHotbar.call(this);

  // ===== BUILD TILE PREVIEW =====
  buildPreview = this.add.graphics();
  buildPreview.setDepth(10);
  buildPreview.setVisible(false);
}

// ================= UPDATE =================
function update(time,delta) {

  this.treeCount.text = 'Wood: ' + Math.trunc(resourceWood);
  this.rockCount.text = 'Stone: ' + Math.trunc(resourceStone);
  this.ironCount.text = 'Iron: ' + Math.trunc(resourceIron);

  this.angleText.setPosition(player.x - 10, player.y - 10);
  this.posx.setPosition(player.x - 10, player.y - 60);
  this.posy.setPosition(player.x - 10, player.y - 30);
  this.curx.setPosition(player.x - 10, player.y - 90);
  this.cury.setPosition(player.x - 10, player.y - 120);

  this.posx.text = 'positionx ' + player.x.toFixed(1);
  this.posy.text = 'positiony ' + player.y.toFixed(1);

  handlePlayerMovement();
  handleHotbarInput();
  farmSystem();

  this.cameras.main.centerOn(player.x, player.y);

  if (updatePlayerChunk()) {
    mapTesselation();
  }

  handleBuildPreview();
  tryPlaceWorkbench();
  updateWorkbenchClaimOverlay();

  updateDayNight(delta);
  trySpawnZombie();
  updateZombies();

  treeTouchCount = 0;
  rockTouchCount = 0;
  ironTouchCount = 0;

}

// ================= HOTBAR FUNCTIONS =================
function createHotbar() {
  const slotSize = 56;
  const spacing = 8;
  const totalWidth = HOTBAR_SLOTS * slotSize + (HOTBAR_SLOTS - 1) * spacing;
  const startX = 1920 / 2 - totalWidth / 2;
  const y = 1080 - 80;

  for (let i = 0; i < HOTBAR_SLOTS; i++) {
    let slot = game.scene.scenes[0].add.rectangle(
      startX + i * (slotSize + spacing) + slotSize / 2,
      y,
      slotSize,
      slotSize,
      0x000000,
      0.4
    )
      .setStrokeStyle(2, 0xffffff)
      .setScrollFactor(0)
      .setInteractive()
      .setDepth(1000);

    slot.on('pointerdown', () => selectHotbarSlot(i));
    hotbarSlots.push(slot);
  }

  let axeIcon = game.scene.scenes[0].add.image(
    hotbarSlots[0].x,
    hotbarSlots[0].y,
    'axe'
  ).setScale(1.75).setScrollFactor(0).setDepth(1001);

  hotbarIcons[0] = axeIcon;

  // Slot 2 (Workbench)
  let workbenchIcon = game.scene.scenes[0].add.image(
    hotbarSlots[1].x,
    hotbarSlots[1].y,
    'workbench'
  )
  .setScale(1)
  .setScrollFactor(0)
  .setDepth(1001);

  hotbarIcons[1] = workbenchIcon;




  updateHotbarSelection();
}




function selectHotbarSlot(index) {
  selectedHotbarSlot = index;
  updateHotbarSelection();
}

function updateHotbarSelection() {
  hotbarSlots.forEach((s, i) => {
    s.setStrokeStyle(2, i === selectedHotbarSlot ? 0xffff00 : 0xffffff);
  });

  // Change player sprite based on selected slot
  if (selectedHotbarSlot === 0) {
    player.setTexture('player');
  }
  else if (selectedHotbarSlot === 1) {
    player.setTexture('playerworkbench');
  }

}

function handleHotbarInput() {
  if (keys.one.isDown) selectHotbarSlot(0);
  if (keys.two.isDown) selectHotbarSlot(1);
  if (keys.three.isDown) selectHotbarSlot(2);
  if (keys.four.isDown) selectHotbarSlot(3);
  if (keys.five.isDown) selectHotbarSlot(4);
  if (keys.six.isDown) selectHotbarSlot(5);
  if (keys.seven.isDown) selectHotbarSlot(6);
  if (keys.eight.isDown) selectHotbarSlot(7);
  if (keys.nine.isDown) selectHotbarSlot(8);
}

// ================= FARMING =================
function farmSystem() {
  if (!pointer.isDown) return;
  if(selectedHotbarSlot != 0) return;

  if (treeTouchCount > 0) resourceWood += FARM_RATE * treeTouchCount;
  if (rockTouchCount > 0) resourceStone += FARM_RATE * rockTouchCount;
  if (ironTouchCount > 0) resourceIron += FARM_RATE * ironTouchCount;
}

// ================= MOVEMENT =================
function handlePlayerMovement() {

  if ((cursors.left.isDown && player.x >= 0) || (keys.left.isDown && player.x >= 0)) {
    player.setVelocityX(-200);
    if (cursors.shift.isDown) player.setVelocityX(-300);
  }
  else if ((cursors.right.isDown && player.x <= xLimit) || (keys.right.isDown && player.x <= xLimit)) {
    player.setVelocityX(200);
    if (cursors.shift.isDown) player.setVelocityX(300);
  }
  else {
    player.setVelocityX(0);
  }

  if ((cursors.up.isDown && player.y >= 0) || (keys.up.isDown && player.y >= 0)) {
    player.setVelocityY(-200);
    if (cursors.shift.isDown) player.setVelocityY(-300);
  }
  else if ((cursors.down.isDown && player.y <= yLimit) || (keys.down.isDown && player.y <= yLimit)) {
    player.setVelocityY(200);
    if (cursors.shift.isDown) player.setVelocityY(300);
  }
  else {
    player.setVelocityY(0);
  }
}

function updatePlayerChunk() {
  let cx = closestChunkBoundary(player.x);
  let cy = closestChunkBoundary(player.y);
  let changed = cx !== playerXChunk || cy !== playerYChunk;
  playerXChunk = cx;
  playerYChunk = cy;
  return changed;
}

function mapTesselation() {
  let iIndex = 0;
  for (var i = backgroundDifferenceBehind(background_chunk_width); i <= backgroundDifferenceInFront(background_chunk_width); i += background_size) {
    let jIndex = 0;
    for (var j = backgroundDifferenceBehind(background_chunk_height); j <= backgroundDifferenceInFront(background_chunk_height); j += background_size) {
      background[iIndex][jIndex].setPosition(playerXChunk + i, playerYChunk + j);
      jIndex++;
    }
    iIndex++;
  }
}

function updateDayNight(delta) {

  // Advance time
  timeOfDay += delta / 1000 / DAY_LENGTH;
  timeOfDay %= 1;

  // Calculate darkness using cosine curve (smooth)
  // Noon = 0 darkness, Midnight = max darkness
  const darkness = Math.max(
    0,
    Math.cos((timeOfDay - 0.5) * Math.PI * 2)
  );

  // Tune night strength here
  const alpha = Phaser.Math.Clamp(darkness * 0.6, 0, 0.6);

  dayNightOverlay.clear();
  dayNightOverlay.fillStyle(0x000000, alpha);
  dayNightOverlay.fillRect(0, 0, 1920, 1080);
}

function trySpawnZombie() {

  // Reset flag when day
  if (!isNight()) {
    zombieSpawnedThisNight = false;
    return;
  }

  // Must have a workbench
  if (workbenches.countActive(true) === 0) return;

  // Only once per night
  if (zombieSpawnedThisNight) return;

  const bench = workbenches.getChildren()[0];
  if (!bench) return;

  const distance = ZOMBIE_SPAWN_DISTANCE_TILES * BUILD_TILE_SIZE;
  const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);

  let x = bench.x + Math.cos(angle) * distance;
  let y = bench.y + Math.sin(angle) * distance;


  const zombie = zombies.create(x, y, 'zombie');
  zombie.setScale(2.5);

  // âœ… SAME HITBOX AS PLAYER
  zombie.body.setCircle(10,22,18);

  zombie.setCollideWorldBounds(true);
  zombie.speed = 60;

  zombieSpawnedThisNight = true;

  console.log("ðŸ§Ÿ Zombie spawned at night!");
}

function updateZombies() {

  if (workbenches.countActive(true) === 0) return;

  const bench = workbenches.getChildren()[0];

  zombies.getChildren().forEach(zombie => {

    const angle = Phaser.Math.Angle.Between(
      zombie.x,
      zombie.y,
      bench.x,
      bench.y
    );

    zombie.setRotation(angle);

    zombie.setVelocity(
      Math.cos(angle) * zombie.speed,
      Math.sin(angle) * zombie.speed
    );
  });
}

</script>

</body>
</html>