<html>

<head>
  <script src="https://cdn.jsdelivr.net/npm/phaser@v3.16.2/dist/phaser.js"></script>
</head>

<body>

  <script>

    var config = { //create configuration for game
      type: Phaser.Canvas,
      roundPixels: true,
      width: 1920,
      height: 1080,
      scale:
      {
        mode: Phaser.Scale.ENVELOP,
      },
      physics: {
        default: 'arcade', //the physics engine the game will use
        arcade: {
          fixedStep: false,
          debug: true,
          debugShowBody: true,
          fps: 360
        }
      },
      scene: {
        preload: preload,
        create: create,
        update: update
      }
    };

    var game = new Phaser.Game(config); //create the game object

    //initialise global variables
    var player;
    var obstacles;
    var cursors;

    var yLimit;
    var xLimit;

    
    const background_size = 468
    const background_chunk_width = 8
    const background_chunk_height = 5
    var background = [];

    var playerXChunk = undefined
    var playerYChunk = undefined

    function preload() { //this function loads images before the game starts
      //each image is given a name that is used to refer to it later on
      this.load.image('floor', 'assets/therealtile.png');
      this.load.image('player', 'assets/player.png');
      this.load.image('obstacle', 'assets/obstacle.png');
    }

    function closestChunkBoundary(position) {
      // position = Math.floor(position)
      return Math.floor(position / background_size) * background_size
    }

    function backgroundDifferenceBehind(count) {
      return background_size * Math.ceil(count / -2)
    }

    function backgroundDifferenceInFront(count) {
      return background_size * Math.floor(count / 2)
    }

    function create() { //this function creates sprites at the start of the game
      //randomly generate x and y starting position
      var playerp_ox = Phaser.Math.Between(0, 4680);
      var playerp_oy = Phaser.Math.Between(0, 4680);

      playerXChunk = closestChunkBoundary(playerp_ox)
      playerYChunk = closestChunkBoundary(playerp_oy)

      xLimit = 4680; //the player cannot go beyond these x and
      yLimit = 4680; //y positions
      //create the player sprite
      //make it appear smaller

      for (var i = backgroundDifferenceBehind(background_chunk_width); i <= backgroundDifferenceInFront(background_chunk_width); i += background_size) {
        var xArray = []
        for (var j = backgroundDifferenceBehind(background_chunk_height); j <= backgroundDifferenceInFront(background_chunk_height); j += background_size) {
          // player.x = 758 / background_width = 1 * background_width = 468
          // positions
          let xPos = playerp_ox + i
          let yPos = playerp_oy + j
          let xBoundary = closestChunkBoundary(xPos)
          let yBoundary = closestChunkBoundary(yPos)
          
          // modify image
          var image = this.add.image(xBoundary, yBoundary, 'floor')
          image.setScale(3)
          image.depth = -5

          // add image
          xArray.push(image);
        }
        background.push(xArray)
      }
      

      player = this.physics.add.sprite(playerp_ox, playerp_oy, 'player');
      player.setScale(3);
      // player.frame.rotated = true;
      // player.frame.cutHeight = 30;
      // player.frame.cutWidth = 30;
      // player.frame.pivotX = 15;
      // player.frame.pivotY = 15;

      console.log(player)
      cursors = this.input.keyboard.createCursorKeys(); //creates an object containing hotkeys
      keys = this.input.keyboard.addKeys({ up: 'W', left: 'A', down: 'S', right: 'D' });
      // -> { up: Key, left: Key, down: Key, right: Key }

      this.cameras.main.setBounds(-955, -520, xLimit + 1920, yLimit + 1080);

      obstacles = this.physics.add.staticGroup(); //create group for obstacles

      var treeCount = 15;
      var trees = [];

      for (let i = 0; i < treeCount; i++) {
        var treeLocX = Phaser.Math.Between(0, 3825);
        var treeLocY = Phaser.Math.Between(0, 2155);

        let1 = obstacles.create(treeLocX, treeLocY, 'obstacle').setCircle(75);
        trees[i] = let1;

      }

      this.physics.add.collider(player, obstacles); //collision detection between player and obstacles
      player.setCircle(16, 15, 15);

      this.text = this.add.text(player.x, player.y, 'angle');
      this.posx = this.add.text(15, 15, 'positionx');
      this.posy = this.add.text(15, 30, 'positiony');
      this.curx = this.add.text(15, 45, 'curx');
      this.cury = this.add.text(15, 60, 'cury');


      this.input.on('pointermove', function (pointer) {
        var angle = Phaser.Math.RAD_TO_DEG * Phaser.Math.Angle.Between(player.x, player.y, pointer.worldX, pointer.worldY);
        player.setAngle(angle);
        this.text.text = 'angle: ' + angle;
        this.curx.text = 'pcurx ' + pointer.worldX;
        this.cury.text = 'pcury ' + pointer.worldY;
      }, this);

    }

    function update() { //this function runs every frame
      //debugging shit for positioning

      this.posx.text = 'positionx ' + player.x;
      this.posy.text = 'positiony ' + player.y;

      this.text.setPosition(player.x - 10, player.y - 10);

      this.posx.setPosition(player.x - 10, player.y - 60);
      this.posy.setPosition(player.x - 10, player.y - 30);

      this.curx.setPosition(player.x - 10, player.y - 90);
      this.cury.setPosition(player.x - 10, player.y - 120);

      handlePlayerMovement()

      this.cameras.main.centerOn(player.x, player.y);

      let playerChunkDidChange = updatePlayerChunk()
      if(playerChunkDidChange) {
        mapTesselation()
      }
    }

    function handlePlayerMovement() {
      //player movement
      if ((cursors.left.isDown && player.x >= 0) || (keys.left.isDown && player.x >= 0)) {
        player.setVelocityX(-200); //go left
        if (cursors.shift.isDown) {
          player.setVelocityX(-300);
        }
      }
      else if ((cursors.right.isDown && player.x <= xLimit) || (keys.right.isDown && player.x <= xLimit)) {
        player.setVelocityX(200); //go right
        if (cursors.shift.isDown) {
          player.setVelocityX(300);
        }
      }
      else {
        player.setVelocityX(0); //don't move left or right
      }
      if ((cursors.up.isDown && player.y >= 0) || (keys.up.isDown && player.y >= 0)) {
        player.setVelocityY(-200); //move up
        if (cursors.shift.isDown) {
          player.setVelocityY(-300);
        }

      }
      else if ((cursors.down.isDown && player.y <= yLimit) || (keys.down.isDown && player.y <= yLimit)) {
        player.setVelocityY(200); //move down
        if (cursors.shift.isDown) {
          player.setVelocityY(300);
        }
      }
      else {
        player.setVelocityY(0); //don't move up or down
      }
    }

    // returns true if chunk has changed, false otherwise
    function updatePlayerChunk() {
      let chunkX = closestChunkBoundary(player.x)
      let chunkY = closestChunkBoundary(player.y)

      var result = false

      if(chunkX != playerXChunk || chunkY != playerYChunk) {
        result = true
      }

      playerXChunk = chunkX
      playerYChunk = chunkY

      return result
    }
    
    function mapTesselation() {
      var iIndex = 0
      for (var i = backgroundDifferenceBehind(background_chunk_width); i <= backgroundDifferenceInFront(background_chunk_width); i += background_size) {
        var jIndex = 0
        for (var j = backgroundDifferenceBehind(background_chunk_height); j <= backgroundDifferenceInFront(background_chunk_height); j += background_size) {
          background[iIndex][jIndex].setPosition(playerXChunk + i, playerYChunk + j)

          jIndex++
        }
        iIndex++
      }
    }

  </script>

</body>

</html>