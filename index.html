<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@v3.16.2/dist/phaser.js"></script>
</head>
<body>
 
<script>





var config = { //create configuration for game
  type: Phaser.Canvas,
  roundPixels: true,
    width: 1920,
    height: 1080,
    scale:
    {
        mode: Phaser.Scale.ENVELOP,
    },
  physics: {
    default: 'arcade', //the physics engine the game will use
    arcade: {
      fixedStep: false,
      debug: true,
      debugShowBody: true,
      fps: 360
    }
  },
  scene: {
    preload: preload,
    create: create,
    update: update
  }
};
 
var game = new Phaser.Game(config); //create the game object
 
//initialise global variables
var player;
var obstacles;
var cursors;
 
var yLimit;
var xLimit;
 
function preload () { //this function loads images before the game starts
  //each image is given a name that is used to refer to it later on
  this.load.image('floor', 'assets/therealtile.png');
  this.load.image('player', 'assets/playerwithaxe.png');
  this.load.image('obstacle','assets/obstacle.png');
}
 
function create () { //this function creates sprites at the start of the game
  



//randomly generate x and y starting position
  var playerp_ox = Phaser.Math.Between(0, 4680);
  var playerp_oy = Phaser.Math.Between(0, 4680);

  //let background = this.add.image(234,234, 'floor').setScale(3);
  

  xLimit = 4680; //the player cannot go beyond these x and
  yLimit = 4680; //y positions
 //create the player sprite
 //make it appear smaller
  player = this.physics.add.sprite(playerp_ox, playerp_oy, 'player');
  player.setScale(3);
  cursors = this.input.keyboard.createCursorKeys(); //creates an object containing hotkeys
  keys = this.input.keyboard.addKeys({ up: 'W', left: 'A', down: 'S', right: 'D' });
  // -> { up: Key, left: Key, down: Key, right: Key }
 
  this.cameras.main.setBounds(-955, -520, xLimit+1920, yLimit+1080);
 
  obstacles = this.physics.add.staticGroup(); //create group for obstacles

  var treeCount = 15;
  var trees = [];

  for (let i = 0; i < treeCount; i++) 
  {
    var treeLocX = Phaser.Math.Between(0,3825);
    var treeLocY = Phaser.Math.Between(0,2155);

    let1 = obstacles.create(treeLocX,treeLocY,'obstacle').setCircle(75);
    trees[i] = let1;
  }

  
  this.physics.add.collider(player,obstacles); //collision detection between player and obstacles
  player.setCircle(16,15,-2);

  this.text = this.add.text(player.x,player.y,'angle');
  this.posx = this.add.text(15,15,'positionx');
  this.posy = this.add.text(15,30, 'positiony');
  this.curx = this.add.text(15,45, 'curx');
  this.cury = this.add.text(15,60,'cury');
  this.loadX = this.add.text(15,85,'loadX');
  this.loadY = this.add.text(15,100, 'loadY');




  this.input.on('pointermove', function(pointer) {
        var angle = Phaser.Math.RAD_TO_DEG * Phaser.Math.Angle.Between(player.x, player.y, pointer.worldX, pointer.worldY);
        player.setAngle(angle);
        this.text.text = 'angle: ' + angle;
        this.curx.text = 'pcurx ' + pointer.worldX;
        this.cury.text = 'pcury ' + pointer.worldY;
    }, this);

}

function update () { //this function runs every frame
  var backgroundx = [234,702,1170,1638,2106,2574,3042,3510,3978,4446];
  var background = [];

  var loadingX = [];
  loadingX.push(closest(player.x-468-468,backgroundx));
  loadingX.push(closest(player.x-468,backgroundx));
  loadingX.push(closest(player.x,backgroundx));
  loadingX.push(closest(player.x+468,backgroundx));
  loadingX.push(closest(player.x+468+468,backgroundx));

  var loadingY = [];
  loadingY.push(closest(player.y-468,backgroundx));
  loadingY.push(closest(player.y,backgroundx));
  loadingY.push(closest(player.y+468,backgroundx));

if(cursors.left.isDown || keys.left.isDown || cursors.right.isDown || keys.right.isDown || cursors.up.isDown || keys.up.isDown || cursors.down.isDown || keys.down.isDown) 
{
  for(let i = 0; i < loadingX.length; i++)
  {
    for(let j = 0; j < loadingY.length; j++)
    {
      background[i+j] = this.add.image(loadingX[i],loadingY[j], 'floor').setScale(3);
      background[i+j].depth = -5;
    }
  }
}

  this.loadX.text = 'loadingX ' + loadingX;
  this.loadY.text = 'loadingY ' + loadingY;

  this.loadX.setPosition(player.x-10, player.y-150);
  this.loadY.setPosition(player.x-10, player.y-175);


  this.posx.text = 'positionx ' + player.x;
  this.posy.text = 'positiony ' + player.y;


  this.text.setPosition(player.x-10, player.y-10);
         
  this.posx.setPosition(player.x-10, player.y-60);
  this.posy.setPosition(player.x-10, player.y-30);

  this.curx.setPosition(player.x-10, player.y-90);
  this.cury.setPosition(player.x-10, player.y-120);


  if ((cursors.left.isDown && player.x >= 0) || (keys.left.isDown && player.x >= 0)) 
  {
      player.setVelocityX(-200); //go left
      if(cursors.shift.isDown)
      {
        player.setVelocityX(-300);
      }
  }
  else if ((cursors.right.isDown && player.x <= xLimit)  || (keys.right.isDown && player.x <= xLimit)) {
      player.setVelocityX(200); //go right
      if(cursors.shift.isDown)
      {
        player.setVelocityX(300);
      }
  }
  else {
      player.setVelocityX(0); //don't move left or right
  }
  if ((cursors.up.isDown && player.y >= 0) || (keys.up.isDown && player.y >= 0)) {
      player.setVelocityY(-200); //move up
      if(cursors.shift.isDown)
      {
        player.setVelocityY(-300);
      }
      
  }
  else if ((cursors.down.isDown && player.y <= yLimit) || (keys.down.isDown && player.y <= yLimit)) {
      player.setVelocityY(200); //move down
      if(cursors.shift.isDown)
      {
        player.setVelocityY(300);
      }
  }
  else {
      player.setVelocityY(0); //don't move up or down
  }
 
    this.cameras.main.centerOn(player.x,player.y);
}
function closest (num, arr) {
                var curr = arr[0];
                var diff = Math.abs (num - curr);
                for (var val = 0; val < arr.length; val++) {
                    var newdiff = Math.abs (num - arr[val]);
                    if (newdiff < diff) {
                        diff = newdiff;
                        curr = arr[val];
                    }
                }
                return curr;
            }
</script>
 
</body>
</html>



